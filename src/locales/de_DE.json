{
  "root": "value",
  "key": "",
  "messages": {
    "wrapArrays": true
  },
  "any": {
    "unknown": "ist nicht erlaubt",
    "invalid": "Das Feld beinhaltet einen ungültigen Wert",
    "empty": "Das Feld darf nicht leer sein",
    "required": "Das Feld ist obligatorisch",
    "allowOnly": "Das Feld muss eins von {{valids}} sein",
    "default": "beim Ausführen der Standardmethode ist ein Fehler aufgetreten"
  },
  "alternatives": {
    "base": "stimmt nicht mit einer der zulässigen Alternativen überein"
  },
  "array": {
    "base": "muss eine Liste sein",
    "includes":
      "an der Position {{pos}} passt es nicht zu den zulässigen Typen",
    "includesSingle":
      "Einzelwert von \"{{!key}}\" passt nicht zu den zulässigen Typen",
    "includesOne": "an der Position {{pos}} scheitert weil {{reason}}",
    "includesOneSingle":
      "Einzelwert von \"{{!key}}\" scheitert weil {{reason}}",
    "includesRequiredUnknowns":
      "beinhaltet keine {{unknownMisses}} erforderliche Wert(e)",
    "includesRequiredKnowns": "beinhaltet nicht {{knownMisses}}",
    "includesRequiredBoth":
      "beinhaltet nicht {{knownMisses}} und {{unknownMisses}} weitere erforderliche Wert(e)",
    "excludes": "an der Position {{pos}} enthält einen ausgeschlossenen Wert",
    "excludesSingle":
      "Einzelwert von \"{{!key}}\" enthält einen ausgeschlossenen Wert",
    "min": "muss mindestens {{limit}} Elemente enthalten",
    "max": "muss weniger als oder gleich {{limit}} Elemente enthalten",
    "length": "muss {{limit}} Elemente enthalten",
    "ordered": "an der Position {{pos}} schlägt es fehl, weil {{reason}}",
    "orderedLength":
      "an der Position {{pos}} schlägt es fehl, weil das Array höchstens {{limit}} Elemente enthalten darf",
    "sparse": "darf kein Array mit Nullwerten sein",
    "unique": "die Position {{pos}} enthält einen doppelten Wert"
  },
  "boolean": {
    "base": "muss ein Boolean sein"
  },
  "binary": {
    "base": "muss ein Buffer oder String sein",
    "min": "muss mindestes {{limit}} Bytes sein",
    "max": "muss weniger oder gleich {{limit}} Bytes sein",
    "length": "muss {{limit}} Bytes sein"
  },
  "date": {
    "base":
      "muss eine Anzahl von Millisekunden oder eine gültige Datumszeichenfolge sein",
    "min": "muss größer oder gleich \"{{limit}}\" sein",
    "max": "must be less than or equal to \"{{limit}}\"",
    "isoDate": "muss ein gültiges ISO 8601-Datum sein",
    "ref": "referenziert \"{{ref}}\" was kein Datum ist"
  },
  "function": {
    "base": "muss eine Function sein"
  },
  "object": {
    "base": "muss ein Object sein",
    "child": "Kind \"{{!key}}\" scheitert weil {{reason}}",
    "min": "muss mindestens {{limit}} Kinder haben",
    "max": "muss weniger oder gleich {{limit}} Kinder enthalten",
    "length": "muss {{limit}} Kinder enthalten",
    "allowUnknown": "ist nicht erlaubt",
    "with": "fehlender erforderlicher Peer \"{{peer}}\"",
    "without": "Konflikt mit verbotenen Peer \"{{peer}}\"",
    "missing": "muss mindestens einen von {{peers}} enthalten",
    "xor": "enthält einen Konflikt zwischen exklusiven Peers {{peers}}",
    "or": "muss mindestens einen von {{peers}} enthalten",
    "and": "enthält {{present}} ohne folgende erforderlichen Peers {{missing}}",
    "nand": "!!\"{{main}}\" darf nicht gleichzeitig mit {{peers}} existieren",
    "assert":
      "!!\"{{ref}}\" Validierung fehlgeschlagen, weil \"{{ref}}\" {{message}} fehlgeschlagen ist",
    "rename": {
      "multiple":
        "kann das Kind \"{{from}}\" nicht umbenennen, da mehrere Umbenennungen deaktiviert sind und ein anderer Schlüssel bereits in \"{{to}}\" umbenannt wurde",
      "override":
        "kann das Kind \"{{from}}\" nicht umbenennen, weil das Überschreiben deaktiviert ist und das Ziel \"{{to}}\" existiert"
    },
    "type": "muss ein \"{{type}}\" sein"
  },
  "number": {
    "base": "muss eine Number sein",
    "min": "muss größer oder gleich {{limit}} sein",
    "max": "muss kleiner oder gleich {{limit}} sein",
    "less": "muss kleiner als {{limit}} sein",
    "greater": "muss größer als {{limit}} sein",
    "float": "muss ein Float oder Double sein",
    "integer": "muss ein Integer sein",
    "negative": "muss eine negative Zahl sein",
    "positive": "muss eine positive Zahl sein",
    "precision": "darf nicht mehr als {{limit}} Dezimalstellen haben",
    "ref": "referenziert \"{{ref}}\" was keine Number ist",
    "multiple": "muss ein Vielfaches von {{multiple}} sein"
  },
  "string": {
    "base": "Hier wird eine Zeichenkette verlangt",
    "min": "Es müssen mindestens {{limit}} Zeichen eingegeben werden",
    "max": "Es dürfen höchstens {{limit}} eingegeben werden",
    "length": "Das Wort muss eine Länge von {{limit}} Zeichen besitzen",
    "alphanum": "Es dürfen nur alphanumerische Zeichen verwendet werden",
    "token": "darf nur alphanumerische Zeichen und Unterstriche enthalten",
    "regex": {
      "base":
        "mit Wert \"{{!value}}\" stimt es nicht mit dem erforderlichen Muster überein: {{pattern}}",
      "name":
        "mit Wert \"{{!value}}\" stimt es nicht mit dem {{name}} Muster überein"
    },
    "email": "Die eingegebene Emailadresse muss valide sein (mit @ und .)",
    "uri": "muss eine valide URI sein",
    "uriCustomScheme":
      "muss eine valide URI sein mit einem Schema, dass mit dem {{scheme}} Muster übereinstimmt",
    "isoDate": "muss ein gültiges ISO 8601-Datum sein",
    "guid": "muss eine valide GUID sein",
    "hex": "darf nur hexadezimale Zeichen enthalten",
    "hostname": "muss ein gültiger Hostname sein",
    "lowercase": "darf nur Kleinbuchstaben enthalten",
    "uppercase": "darf nur Großbuchstaben enthalten",
    "trim": "darf keine führenden oder nachgestellten Leerzeichen enthalten",
    "creditCard": "muss eine Kreditkarte sein",
    "ref": "Referenziert \"{{ref}}\", was keine Nummer ist",

    "ip": "muss eine gültige IP-Adresse mit einer {{cidr}} CIDR sein",
    "ipVersion":
      "muss eine gültige IP-Adresse sein die mit einer der folgenden Versionen {{version}} und {{cidr}} CIDR übereinstimmt"
  }
}